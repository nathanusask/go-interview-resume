### 1.什么是操作系统？ 

操作系统是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序。

### 2.操作系统的功能 

操作系统的功能主要可以分为以下5个部分 

- 处理器管理，主要控制和管理CPU的工作 
- 存储管理，主要进行内存的分配和管理 
- 设备管理，主要管理基本的输入输出设备 
- 文件管理，负责对计算机文件的组织、存储、操作和保护等 
- 进程管理（作业管理），对计算机所进行的操作进行管理

### 3.什么是用户态和内核态

用户态和内核态是操作系统的两种运行状态，操作系统主要是为了对访问能力进行限制，用户态的权限较低，而内核态的权限较高 

- 用户态：用户态运行的程序只能**受限地访问内存**，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许**独占**，也就是说 CPU 能够被其他程序获取。 
- 内核态：内核态运行的程序可以**访问计算机的任何数据和资源**，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生**抢占**情况。

### 4.❤用户态和内核态是如何切换的? 

先看为什么要进行切换 

用户程序是跑在用户态下的，但有时候会遇到一些操作需要比较高的权限，比如申请内存等，这时候就需要转换到内核态去做。  

内核态切换到用户态是通过设置程序状态字PSW 

导致用户态切换到内核态最主要有**三种场景** 

- **系统调用**，这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。 
- **异常**，当CPU执行运行在用户态下的程序时，发生了异常，这时会从当前的进程切换到处理异常的内核相关程序中，也就是从用户态切换到内核态，比如缺页异常 
- **外围设备的中断**，当外围设备完成用户请求的操作后，会像CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序

### 5.❤进程、线程和协程的区别和联系 

这三者的区别是一个比一个”小“的，一个进程可以包含多个线程，一个线程也可以包含多个协程。 

- 进程：进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程 
- 线程：线程是程序执行的基本单位，是轻量级的进程 
- 协程：用户态轻量级线程，是一种比线程更加轻量级的存在，协程是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处继续运行 

值得注意的是，多进程（多线程）在多核CPU上是可以并行的，但一个线程内的多个协程的运行是串行的，下面看下具体的区别

|          | 进程                       | 线程              | 协程    |
| -------- | ------------------------ | --------------- | ----- |
| 切换者      | 操作系统                     | 操作系统            | 用户    |
| 切换时机     | 操作系统的切换策略决定              | 操作系统的切换策略决定     | 用户决定  |
| 切换内容     | 页全局目录、内核栈、硬件上下文          | 内核栈、硬件上下文       | 硬件上下文 |
| 切换内容的保存  | 内核栈                      | 内核栈             | 内核栈/堆 |
| **切换过程** | 用户态-内核态-用户态              | 用户态-内核态-用户态     | 用户态   |
| 并发问题     | 不同进程之间切换实现并发，各自占有CPU实现并行 | 一个进程内部的多个线程并发执行 | 串行执行  |
| **系统开销** | 很大                       | 较小              | 很小    |

进程和线程的根本区别在于： **多进程中每个进程有自己的地址空间，线程则共享地址空间**。

### 6.Linux系统中一个进程可以创建多少线程 

这个主要和系统的位数有关系 

- 32位，用户态的虚拟空间只有 3G，假设创建一个线程需要占用 10M 虚拟内存，可以创建差不多 300 个（3G/10M）左右的线程 
- 64位，用户态的虚拟空间只有 128T，假设创建一个线程需要占用 10M 虚拟内存，可以创建差不多1000多万（128T/10M）左右的线程，当然了，这只是理论，实际上还会受到系统的参数或性能限制，可能会远远小于这个数值，具体还得取决于那你的系统吸能怎么样

### 7.什么是临界区，如何解决冲突？ 

每个进程中访问临界资源的那段程序称为临界区，一次仅允许一个进程使用的资源称为临界资源。 

解决冲突的办法： 

- 如果有若干进程要求进入空闲的临界区，**一次仅允许一个进程进入**，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待； 
- 进入临界区的进程要在有限时间内退出。 
- 如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象

### 8.并发和并行有什么区别 

- 并行：单位时间多个处理器同时处理多个任务。
- 并发：一个处理器处理多个任务，按时间片轮流处理多个任务。

### 9.什么是上下文切换？

上下文切换指的是内核操作系统的核心在CPU上对进程或者线程进行切换。 

搞清楚上下文切换需要先搞清楚什么是上下文 

CPU在开始执行任务时需要先知道从哪里去加载任务，从哪里开始执行，上下文的作用就是告诉CPU这些。（通常是由程序计数器和CPU寄存器来完成） 

那为什么需要上下文切换呢？ 

一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式，就是一个线程的时间片用完会退回到就绪态，其他线程继续运行，这个过程就是进行了一次上下文切换 

上下文切换的步骤： 

- 挂起一个进程，将这个进程在CPU中的状态（上下文信息）存储于内存的PCB（Process Control Block）中 
- 在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复 
- 最后跳转到程序计数器所指的新位置，运行新任务 

引起线程上下文切换的原因： 

（1）当前正在执行的任务完成，系统的CPU正常调度下一个任务。 

（2）当前正在执行的任务遇到I/O等阻塞操作，调度器挂起此任务，继续调度下一个任务。 （

（3）多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。 

（4）用户的代码挂起当前任务，比如线程执行yield()方法，让出CPU。 

（5）硬件中断。

上下文切换可以分为**进程上下文切换、线程上下文切换、中断上下文切换**三种 

- 进程上下文切换：进程上下文切换需要保存的东西比较多，花费的时间也比较多，进程的上下文主要包括虚拟内存、栈、全局变量、堆栈、寄存器等 线程上下文切换：
- 线程上下文切换时，虚拟内存和全局变量等资源都是共享的，线程的上下文包括栈和寄存器等，比寄存器少很多。 
- 中断上下文切换：为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，然后调用中断处理程序，响应设备事件。中断上下文，只包括内核态中断服务程序执行所必需的状态，也就是 CPU 寄存器、内核堆栈、硬件中断参数等

### 10.进程有哪些状态？ 

进程的状态模型一般可以分为三态模型和五态模型，这里以五态模型为例，三态模型指**就绪、运行、阻塞**（等待） 进程一共有以下几个状态： 

- 就绪状态：：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 
- 运⾏状态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。 
- 阻塞状态：又称等待态，指进程不具备运行条件，正在等待某个时间完成的状态。一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 
- 创建状态：对应于进程被创建时的状态，尚未进入就绪队列。创建一个进程需要通过两个步骤：1.为新进程分配所需要的资源和建立必要的管理信息。2.设置该进程为就绪态，并等待被调度执行。
- 结束状态：：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。 五种状态的转换过程如下：

![img](https://www.mianshi.online/wp-content/uploads/2022/09/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-1.png)

### 11.什么是僵尸进程？什么是孤儿进程？ 

僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。 

例如，当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程 系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 

孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 

当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。也就是说孤儿进程可以正常退出，因此孤儿进程并不会有什么危害

### 12.如何避免僵尸进程？ 

- 让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid(),通知内核释放僵尸进程 
- 采用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数。父进程首先注册一个信号处理函数signal(SIGCHLD, sig_chld_handler)，然后每当子进程退出的时候父进程都会受到SIGCHLD信号， 触发sig_chld_handler()函数，调用wait()函数等待子进程的退出。 
- 让僵尸进程变成孤儿进程，由init回收。例如可以父进程首先创建子进程，子进程创建孙子进程，由孙子进程处理事务，而子进程再创建完孙子进程后，就退出。这样孙子进程就变成了孤儿进程。

### 13.进程有哪些调度算法？ 

先来说下什么是抢占式调度，什么式非抢占式调度 

抢占式调度：现行进程在运行过程中，如果有重要或紧迫的进程到达（其状态必须为就绪），则现运行进程将被迫放弃处理器，系统将处理器立刻分配给新到达的进程 

非抢占式调度：非抢占式让原来正在运行的进程继续运行，直至该进程完成或发生某种事件（如I/O请求），才主动放弃处理机 

**先来先服务（FCFS，first come first served）** 

非抢占式调度算法，这是最简单的一种调度算法，比较好理解，就是根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间。 

优点：公平，实现简单 缺点：比较有利于长作业，而不利于短作业 

**时间片轮转（RR，Round-Robin）** 

抢占式调度，给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，适用于分时系统。 

优点：兼顾长短作业 缺点：平均等待时间较长，上下文切换较费时

**短作业优先（SJF, Shortest Job First）** 

非抢占式调度算法，对预计执行时间短的进程优先处理。对应的还有最短剩余时间优先算法，这是类似抢占式的短作业优先算法 

优点：相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量

缺点：不利于长作业 

**高响应比优先（HRRN，Highest Response Ratio Next）** 

非抢占式调度算法，最高响应比是一种折中的算法，先来先服务主要考虑的是作业的等待时间而未考虑到作业的执行时间，短作业优先主要考虑的是作业的执行时间而未考虑作业等待时间。而最高响应比同时考虑到了两者，其响应比=（预估的进程执行时间+进程等待时间）/ 预估的进程执行时间，这就保证了等待时间相同的情况下，作业执行的时间越短，响应比越高，同时响应比会随着等待时间减小而变大，优先级会提高，能够避免饥饿现象，适用于批处理系统。 

优点：兼顾长短作业 缺点：计算响应比开销大 

**优先级调度算法**

抢占式调度算法，在进程等待队列中选择优先级最高的来执行。 

**多级反馈队列（Multilevel Feedback Queue）** 

抢占式调度算，这是一种将时间片轮转和优先级调度想结合的算法，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转 

优点：兼顾长短作业，有较好的响应时间，可行性强



### 14.线程和进程都怎么通信？

线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。

进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。以前进程间的通信只能是单机版的，现在操作系统都继承了基于套接字（socket）的进程间的通信机制。这样进程间的通信就不局限于单台计算机了，实现了网络通信。

进程间的通信方式
- **管道( pipe )**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。


- **有名管道 (namedpipe)** ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。


- **信号量(semophore )** ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。


- **消息队列( messagequeue )** ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。


- 信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。


- 共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。


- **套接字(socket )** ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

线程间的通信方式

- **锁机制**：包括互斥锁、条件变量、读写锁

  - 互斥锁提供了以排他方式防止数据结构被并发修改的方法。


  - 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。


  - 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- **信号量机制**(Semaphore)：包括无名线程信号量和命名线程信号量

- **信号机制**(Signal)：类似进程间的信号处理

- 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### 15.简述多路IO复用技术

> 参考https://www.jianshu.com/p/111f079315f5

IO 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出 cpu。

IO 是指网络 IO，多路指多个 [TCP](https://www.jianshu.com/p/cae79a66af4a) 连接(即 socket 或者 channel)，复用指复用一个或几个[线程](https://www.jianshu.com/p/6a4947e27114)。意思说一个或一组线程处理多个 TCP 连接。最大优势是减少系统开销，不必创建过多的[进程/线程](https://www.jianshu.com/p/94b7c2ab84ac)，也不必维护这些进程/线程。

IO 多路复用的三种实现方式：select、poll、epoll。

**select 机制**

1️⃣基本原理：
客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和 exceptfds(异常)。select 会阻塞住监视 3 类文件描述符，等有数据、可读、可写、出异常或超时就会返回；返回后通过**遍历** fdset 整个数组来找到就绪的描述符 fd，然后进行对应的 IO 操作。

2️⃣优点：
几乎在所有的平台上支持，跨平台支持性好

3️⃣缺点：

1. 由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
2. 每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)。
3. 单个进程打开的 FD 是有限制(通过`FD_SETSIZE`设置)的，默认是 1024 个，可修改宏定义，但是效率仍然慢。

**poll 机制**

1️⃣基本原理与 select 一致，也是**轮询+遍历**。唯一的区别就是 poll 没有**最大文件描述符限制**(使用[链表](https://www.jianshu.com/p/81a6ed0abeb8)的方式存储 fd)。

2️⃣poll 缺点

1. 由于是采用轮询方式全盘扫描，会随着文件描述符 FD 数量增多而性能下降。
2. 每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)。

**epoll机制**

1️⃣基本原理：
没有 fd 个数限制，用户态拷贝到内核态只需要一次，使用**时间通知机制**来触发。通过 epoll_ctl 注册 fd，一旦 fd 就绪就会通过 callback 回调机制来激活对应 fd，进行相关的 io 操作。
epoll 之所以高性能是得益于它的三个函数：

1. epoll_create() 系统启动时，在 Linux 内核里面申请一个 [B+树](https://www.jianshu.com/p/b597aa97c9de)结构文件系统，返回 epoll 对象，也是一个 fd。
2. epoll_ctl() 每新建一个连接，都通过该函数操作 epoll 对象，在这个对象里面修改添加删除对应的链接 fd，绑定一个 callback 函数
3. epoll_wait() 轮训所有的callback集合，并完成对应的 IO 操作

2️⃣优点：
没 fd 这个限制，所支持的 FD 上限是操作系统的最大文件句柄数，1G 内存大概支持 10 万个句柄。效率提高，使用回调通知而不是轮询的方式，不会随着 FD 数目的增加效率下降。内核和用户空间 mmap 同一块内存实现(mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)

3️⃣epoll缺点：
epoll 只能工作在 [linux](https://www.jianshu.com/p/95d087dc1a43) 下。

4️⃣epoll 应用：**redis、nginx**

### 16.简述进程切换的流程

1.切换页目录以使用新的地址空间

2.切换内核栈和硬件上下文

